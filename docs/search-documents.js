var searchDocuments = {"r0/requestor/index.html":{"action-uuid":"067f1a15-0629-4d7d-b717-2bc39cb5991d","title":"Requestor","content":"Takes a request and orchestrates other components. Implement similar to Loader - a generic (functional) interface with an inheritance hierarchy which progressively binds generic parameters. Concrete implementations as classes or utility methods."},"glossary.html":{"action-uuid":"b22dd9b8-1664-47e0-90b7-5791139f4afc","title":"Glossary","content":"Clear Identifier(s) Hide UUID {{data.value.name}} {{data.value[0].value}} {{item.value}}"},"r0/responder/index.html":{"action-uuid":"8a64559d-4f23-4724-8a2a-34131a376a4f","title":"Responder","content":"Generates a response from: Request Query results Generator&rsquo;s response Similar to the requestor and loader - a generic (functional) interface, inheritance hierarchy, concrete implementations as classes and utility methods: Plain text JSON or some other structure, say response model Markdown/HTML - summary, footnotes, sources."},"r0/loader/index.html":{"action-uuid":"cc8f119d-7d35-480f-b88d-993f238a3340","title":"Loader","content":"Iterates over the data source, uses key extractor to compute a key, stores to the store. The loader may perform a transformation of the data store format to an internal URI -&gt; S format where S is the argument type for the key extractors. For example, String for text embeddings. Implement as a generic (functional) interface with an inheritance hierarchy progressively binding generic parameters. Concrete implementations may be provided as static utility methods."},"r0/query-engine/index.html":{"action-uuid":"ab50bd1b-91f8-418c-8fe9-4b81bf013ad4","title":"Query Engine","content":"Query engine is essentially Function&lt;K,Iterable&lt;R&gt;&gt; or BiFunction&lt;K,ProgressMonitor,Iterable&lt;R&gt;&gt; where R provides access to the source URI and possibly similarity and some metadata. Similarity can be anything including null. There might be a comparator for similarities. For example, cosine similarity comparator. For vectors take a look at https://github.com/jelmerk/hnswlib / https://mvnrepository.com/artifact/com.github.jelmerk/hnswlib-core-jdk17, take a look at embeddings4j - adapt if possible. Hnswlib provides several distance metrics with cosine distance being one of them. Hnswlib can also be used for indexing. The index may be serialized. The index can be used as a store - so provide an index store implementation which combines both an index and query engine. Implementations (solution building blocks to provide): Vector Iteration - takes a similarity computer, iterates over the store, sorts. Index - use Hnswlib, there are two index implementations Vector database, e.g. Milvus Digest - exact match, singleton list as a result Bag of words - explore what Apache OpenNLP, Smile NLP and WordNet have to offer"},"r0/store/index.html":{"action-uuid":"c4f9f605-fd87-4b12-a92f-35dba43118af","title":"Store","content":"Stores associations between keys and data items. Use an Ecore model for store - create model module. Implement storage by reference - use URI&rsquo;s to find source data items in the resource set. Provide implementations for: Vectors Digests - may be used for automated validation of embedding stores - digest based query shall always be a subset of a corresponding vector query. Storage as: XMI - for inspection Compressed binary - for compact storage Delivery vehicles: Local file Maven resource HTTP(S) resource Also provide implementations for a few vector databases: Milvus - it has vendor-provided Java SDK and a docker image provided by VMware"},"index.html":{"action-uuid":"84d71664-ab5c-4ccf-ac4a-a39ed5391ff8","title":"Retrieval Augmented Generation","content":"Nasdanika RAG is a retrieval augmented generation framework in Java. The goal of the framework is to provide Java developers means to assemble RAG designs which match their tasks at hand. The framework takes Capability, Architecture/Solution building blocks approach. Architecture building blocks provide one or more capability, solution building blocks implement one or more architecture building blocks. The diagram above depicts the architecture building blocks. The below diagram shows how the building blocks interact during loading and retrieval/generation phases. hide footbox actor User [[r0/user/index.html]] boundary Requestor [[r0/requestor/index.html]] participant queryEngine as &quot;Query Engine&quot; [[r0/query-engine/index.html]] participant Generator [[r0/generator/index.html]] participant Responder [[r0/responder/index.html]] participant keyExtractor as &quot;Key Extractor&quot; [[r0/key-extractor/index.html]] participant Loader [[r0/loader/index.html]] database dataSources as &quot;Data Sources&quot; [[r0/data-sources/index.html]] database Store [[r0/store/index.html]] group Load Loader -&gt; dataSources : read Loader -&gt; keyExtractor : generate key Loader -&gt; Store : store end group Retrieve &amp; Generate User -&gt; Requestor : question Requestor -&gt; queryEngine : query queryEngine -&gt; keyExtractor : generate query key queryEngine -&gt; Store : get matches queryEngine -&gt; queryEngine : sort by similarity queryEngine --&gt; Requestor : sorted store entries Requestor -&gt; Generator : question and query results Generator --&gt; Requestor : summary Requestor -&gt; Responder : question, query results, summary Responder --&gt; User : answer end For each architecture building block there may be multiple solution building blocks. A combination of compatible solution building blocks is called a &ldquo;design&rdquo; or &ldquo;embodiment&rdquo;. Solution building blocks for the same architecture building block may be chained and composed to produce new solution building blocks. The following sections provide brief overviews of the architecture building blocks. Click on the diagram elements or use the left navigation or links to navigate to the blocks&rsquo; pages with more detailed information and a list of solution building blocks. Data Sources Sources of data. There might be multiple solution building blocks with two primary design dimensions: Data item format - PDF, HTML, JSON, diagram, Ecore model, PNG, JPEG &hellip; Data storage interface - file system, zip archive, (REST) API, &hellip; Data items can be converted from one format to another. As such data sources can be chained and composed. Loader Loads data items keys and some data item identifier/locator to the store to make them discoverable by the query engine. Store Contains associations between data item keys and data items. Data items can be stored by value or by reference. The store can be indexed. A vector database is an example of an indexed store of embedding vectors. Key Extractor Takes a data item of a fragment of it (say a paragraph from a text document) and computes a key. The key is something that identifies the data item. Some key types may support similarity computation. Examples of keys: Text: MD5/SHA digest - exact matches Vector embeddings - cosine similarity Bags of words - overlap similarity Person Postal address - distance similarity DNA - shared DNA Marital and social networks relationships - distance Query Engine Computes query key and retrieves matching items from the store sorted by similarity. Requestor Takes a request, passes to the query engine. Then uses the request and the query results to formulate a request to the generator. For example, if the generator is an LLM, it would create prompts or chains of thought from the query results. Then it passes the request, the query results, and the response from the generator to the responder. Generator Creates a summary response from a request and query results. This component might not be present in some embodiments. E.g. in the case of Semantic Search the Responder will generate a response. Responder Takes the request, query results, generator response and creates a response for the user. User A user (client) of a RAG solution - a human or a system. User A user (client) of a RAG solution - humann or system Data Sources Sources of data items - HTML pages, PDF files, databases, OCR JSON's, diagrams, ... Store Key Extractor Computes store/retrieval key. For example, a vector embedding. Key may have a measure of similarity. For example, cosine similarity for vectors Query Engine Takes a request and uses the key extractor to compute a request key. Then uses the key to retrieve matching items from the store. If the key type supports similarity computation, then orders results by similarity. May index store entries for faster retrieval. Requestor Takes a request, passes to the query engine. Then uses the request and the query results to formulate a request to the generator. For example, if the generator is an LLM, it would create prompts or chains of thought from the query results. Then it passes the request, the query results, and the response from the generator to the responder. Responder Takes the request, query results, generator response and creates a response for the user. Generator Creates a summary response from a request and query results. This component might not be present in some embodiments. E.g. in the case of Semantic Search the Responder will generate a response. Loader Loads data items from data sources to a store for subsequent retrieval. May store by value or by references. May create multiple store entries per data item. For example, it may break down a PDF/HTML documents into sections and then into paragraphs and create entries per paragraph. May also index entries by the key. User A user (client) of a RAG solution - humann or system Data Sources Sources of data items - HTML pages, PDF files, databases, OCR JSON's, diagrams, ... Store Key Extractor Computes store/retrieval key. For example, a vector embedding. Key may have a measure of similarity. For example, cosine similarity for vectors Query Engine Takes a request and uses the key extractor to compute a request key. Then uses the key to retrieve matching items from the store. If the key type supports similarity computation, then orders results by similarity. May index store entries for faster retrieval. Requestor Takes a request, passes to the query engine. Then uses the request and the query results to formulate a request to the generator. For example, if the generator is an LLM, it would create prompts or chains of thought from the query results. Then it passes the request, the query results, and the response from the generator to the responder. Responder Takes the request, query results, generator response and creates a response for the user. Generator Creates a summary response from a request and query results. This component might not be present in some embodiments. E.g. in the case of Semantic Search the Responder will generate a response. Loader Loads data items from data sources to a store for subsequent retrieval. May store by value or by references. May create multiple store entries per data item. For example, it may break down a PDF/HTML documents into sections and then into paragraphs and create entries per paragraph. May also index entries by the key."},"r0/key-extractor/index.html":{"action-uuid":"a60a3536-a1b2-474e-af4a-a1044d6aa604","title":"Key Extractor","content":"Implementations: Digest - MD5 and SHA in the core module OpenAI/Azure in the open-ai module using Azure OpenAI Java API - Azure OpenAI client library for Java | Microsoft Learn, Maven Central Open source models like Llama 2, MPT-7B, &hellip; Generic REST API in the core module Bag of words, word2vec and other things provided by Apache OpenNLP and Smile NLP possibly in combination with WordNet"},"r0/generator/index.html":{"action-uuid":"73344b59-84ed-4668-ab0d-ef76d5a4c57f","title":"Generator","content":"Implementations: OpenAI summarization with prompts and chains of thought using the open-ai module using Azure OpenAI Java API - Azure OpenAI client library for Java | Microsoft Learn, Maven Central Generic REST API in the core module Open source models like Llama 2, MPT-7B, &hellip;"},"r0/data-sources/index.html":{"action-uuid":"1c81631e-81ca-43e4-85d9-28094502f68c","title":"Data Sources","content":"Data sources contain data items. A data item is anything from which one or more keys can be extracted: Text Image Graph PDF, HTML, Markdown - a graph of text nodes (sections/paragraphs/sentences) Formatted text - a tree of text nodes (paragraphs/sentences) Source files such as Java - parse tree Drawio diagrams - diagram elements may have label text node, tooltip text node/graph, documentation text nodes/graph OCR Json Ecore models (which includes drawio diagrams) A data source may be implemented as: File system Zip archive Source repository (Git, GitHub, GitLab). gitlab4j-api and GitLab model built on top of it may be used to retrieve items from GitLab. (REST) API Maven repositories Relational databases &hellip; Ecore resources and resource factories may be used as an abstraction layer to represent all types of data sources and data items as Ecore resources in which all elements are identified by URI&rsquo;s: URI converters and handlers allow to load from different storage formats. For example, a custom URI handler for gitlab URI scheme may load from a GitLab server using REST API without cloning repositories, maven URI handler may load from Maven repositories/archives. Resource factories may be used to load resources differently based on extensions. For example: md extension would be treated as a Markdown file - convert to HTML and then use HTML loader to convert to some internal implementation. Nasdanika provides resource factories for Drawio diagrams and Excel files. html and htm extensions would be handled by an HTML factory which may parse HTML using Jsoup and then structure HTML contents into sections using H tag hierarchy, then to paragraphs and sentences. It may compute cross-references between files (resources) and parts of the document. These cross-references may be taken into account when computing similarity. Ecore resource set do not provide functionality for iterating over different storage systems, they load resources from URI&rsquo;s using resource factories. As such, the data source ecosystem would include the following: Storage navigators implementing Iterable&lt;URI&gt;1 URI handlers for URI&rsquo;s which can be loaded as streams (files). Resources and resource factories. Depending on a resource type, resources can be loaded from streams delegating to URI handlers to open them. Or they may use custom logic to load a resource. For example, JDBC to load from a relational database. The data sources ecosystem doesn&rsquo;t have to be RAG-specific - it can be used for other purposes as well. For example, for reasoning. Roadmap Create a common module for common functionality. Implement storage navigators for: File system Zip archives Generic REST API - GET to list directories and download resources. Token based authentication. Implement resources and resource factories for: HTML using [Jsoup](https://jsoup.org/ and HTML model PDF using Apache PDFBox Markdown using MarkdownHelper Plain text. Use String for sentences. For plain text use List of strings for paragraphs. Resources shall implement lookup by URI fragment. For example, line/column number for plain text and markdown, CSS path for HTML, TBD for PDF. EMF URI â†©"}}